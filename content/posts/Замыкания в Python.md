---
title: Замыкания в Python
date: 2023-06-18T11:48:00+03:00
draft: true
---

Не каждый программист хорошо понимает, что такое замыкание. Это довольно интересный эффект, и я попробую объяснить его в этой статье.

### Что такое замыкание?

Давайте посмотрим на этот пример:
```python
def say_name(name):
    def say_goodbye():
        print(f"Don't say me goodbye, {name}!")
    return say_goodbye


f = say_name('Andrei')
f()  # Don't say me goodbye, Andrei!
```

Мы определили функцию внутри другой функции и вернули внутреннюю функцию как объект. Затем мы вызвали внешнюю функцию, передав ей какой-то аргумент, присвоили результат вызова переменной. И так как внешняя функция возвращает внутреннюю, в переменную у нас попала функция. И теперь мы можем использовать эту переменную как функцию, вызвав её. Вроде как всё выглядит хорошо, верно? Или нет? 

Если вы подумаете над этим кодом, вы найдете некоторую странную вещь: как вызов `f()` знает значение переменной `name`? `f` указывает на внутреннюю функцию, которая не принимает никаких параметров. В этом вызове мы не задаем никаких имен. 

Хорошо, давайте возьмем еще один пример, более странный:
```python
def counter(value=0):
    def plus_one():
        nonlocal value
        value += 1
        return value
    return plus_one


c = counter()

print(c())  # 1
print(c())  # 2
```

Здесь мы добавили выражение `nonlocal` чтобы иметь возможность изменять переменную `value` в enclosing окружении из локального окружения. Итак, что же здесь происходит? Когда я в первый раз увидел этот пример, я был удивлен. Каким-то образом `value` запоминает своё значение между вызовами `c()`. Нет никаких глобальных переменных, которые хранят значение `value`. Так где же оно хранится? И что, черт возьми, тут происходит? :)

Хорошо, давайте я вам объясню. Когда мы вызываем внутреннюю функцию в глобальном окружении, интерпретатор python создает снапшот всех используемых переменных в enclosing области, вне зависимости от их вложенности). Интерпретатор собирает все ссылки на все объекты используемые во внутренних функциях и сохраняет их в кортеже с названием `closure` (ага, вот где впервые мы находим это слово). Вы можете даже посмотреть на этот кортеж, если вызовите магический метод `__closure__` у внутренней функции. Таким образом, вы можете увидеть, как переменные **замыкаются** в нашем примере:
```python
def counter(value=0):
    def plus_one():
        nonlocal value
        value += 1
        return value
    return plus_one


c = counter()
print(c.__closure__)  # (<cell at 0x1017da4c0: int object at 0x10156b910>,)
print(c.__closure__[0].cell_contents)  # 0
c()
print(c.__closure__[0].cell_contents)  # 1
```

Итак, ответ на вопрос "где хранится значение `value`?" такой: в магическом методе `__closure__` внутренней функции. Имейте ввиду, что мы не можем напрямую поменять хранимые там значения переменных. Потому что туда не существует прямого доступа. И вы не сможете поменять порядок хранимых переменных (потому что это кортеж).